<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="format-detection" content="telephone=no" />
  <title>ì†ê°€ë½ ë¹¨ê¸° STOP! ë†€ì´ë¡œ ë©ˆì¶”ëŠ” ê²Œì„</title>

  <style>
    :root{
      --ink:#1f1f1f;
      --panel:rgba(255,255,255,0.92);
      --shadow:rgba(0,0,0,0.16);
      --btn:#ff6b6b;
    }
    *{ box-sizing:border-box; }
    html,body{
      height:100%;
      margin:0;
      background:#ffffff;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",Arial,sans-serif;
      color:var(--ink);
      overscroll-behavior:none;
      touch-action:none;
    }
    #wrap{position:relative;height:100%;width:100%;}
    canvas{width:100vw;height:100vh;display:block;background:#ffffff;}

    .hud{
      position:absolute;
      top: env(safe-area-inset-top, 0px);
      left: env(safe-area-inset-left, 0px);
      right: env(safe-area-inset-right, 0px);
      padding:10px 14px;
      display:flex;justify-content:space-between;align-items:center;
      pointer-events:none;user-select:none;
      font-weight:1000;letter-spacing:-0.2px;
      text-shadow:0 1px 0 rgba(255,255,255,0.8);
      gap:10px;
    }
    .hudRight{display:flex;gap:10px;align-items:center;justify-content:flex-end;}
    .chip{
      background:rgba(255,255,255,0.78);
      border-radius:999px;
      padding:8px 12px;
      box-shadow:0 6px 16px var(--shadow);
      border:1px solid rgba(0,0,0,0.06);
      pointer-events:none;
      white-space:nowrap;
    }
    .iconBtn{
      pointer-events:auto;
      border:1px solid rgba(0,0,0,0.08);
      background:rgba(255,255,255,0.78);
      border-radius:999px;
      padding:8px 10px;
      box-shadow:0 6px 16px var(--shadow);
      font-weight:900;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .iconBtn:active{transform:translateY(1px);}

    .overlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:
        calc(18px + env(safe-area-inset-top, 0px))
        calc(18px + env(safe-area-inset-right, 0px))
        calc(18px + env(safe-area-inset-bottom, 0px))
        calc(18px + env(safe-area-inset-left, 0px));
      background:rgba(0,0,0,0.14);
    }
    .panel{
      width:min(560px,92vw);
      border-radius:22px;
      background:var(--panel);
      box-shadow:0 18px 40px var(--shadow);
      padding:18px 16px 16px;
      text-align:center;
      backdrop-filter:saturate(1.2) blur(2px);
    }
    .panel h1{margin:6px 0 10px;font-size:22px;letter-spacing:-0.4px;}
    .panel p{margin:8px 0 14px;font-size:15px;opacity:0.92;}

    .rules{
      text-align:left;
      margin:10px 0 14px;
      padding:12px 12px;
      border-radius:14px;
      background:rgba(255,255,255,0.75);
      border:1px solid rgba(0,0,0,0.06);
      box-shadow:0 8px 18px rgba(0,0,0,0.06);
      font-size:14px;
      line-height:1.55;
    }
    .rules b{font-weight:900;}

    .btn{
      appearance:none;border:0;border-radius:16px;
      padding:14px 16px;width:100%;
      font-size:18px;font-weight:1000;
      cursor:pointer;
      box-shadow:0 12px 24px var(--shadow);
      color:#fff;
      background:linear-gradient(135deg,var(--btn) 0%, #ff3d3d 100%);
    }
    .btn.secondary{
      margin-top:10px;
      background:linear-gradient(135deg,#ffb703 0%, #fb8500 100%);
    }
    .btn:active{transform:translateY(1px);}
    .sub{margin-top:10px;font-size:13px;opacity:0.75;line-height:1.4;}
  </style>
</head>

<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="chip" id="scoreChip">ì ìˆ˜: 0</div>
    <div class="hudRight">
      <div class="chip" id="hintChip">ì‹œì‘í•˜ê¸°ë¥¼ ëˆŒëŸ¬ì£¼ì„¸ìš”</div>
      <button class="iconBtn" id="soundBtn" type="button" aria-label="ì‚¬ìš´ë“œ í† ê¸€">ğŸ”Š</button>
    </div>
  </div>

  <div class="overlay" id="startOverlay" style="display:flex;">
    <div class="panel">
      <h1>ì†ê°€ë½ ë¹¨ê¸° STOP!</h1>
      <div class="rules" id="rulesBox">
        <div>â€¢ <b>ë°©ë²•</b>: ì†ê°€ë½ì´ <b>ì…</b>ì— ë‹¿ê¸° ì „ì— ë§‰ì•„ì£¼ì„¸ìš”.</div>
        <div>â€¢ <b>ì¡°ì‘</b>: ë‚ ì•„ì˜¤ëŠ” ì†ì„ <b>í„°ì¹˜</b>í•˜ë©´ ì‚¬ë¼ì ¸ìš”.</div>
      </div>
      <button class="btn" id="startBtn">ì‹œì‘í•˜ê¸°</button>
      <div class="sub">â€» ì‚¬ìš´ë“œëŠ” ìƒë‹¨ ğŸ”Š ë²„íŠ¼ìœ¼ë¡œ ëŒ ìˆ˜ ìˆì–´ìš”</div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="panel">
      <h1>ìœ¼~ ë„ˆë¬´ ì¨!</h1>
      <p id="finalScore">ìµœì¢… ì ìˆ˜: 0</p>

      <!-- âœ… TOP10 ì ìˆ˜íŒ -->
      <div class="rules" id="leaderboardBox" style="margin-top:12px;">
        <div style="font-weight:900;margin-bottom:8px;">ğŸ† TOP10 ì ìˆ˜</div>
        <div id="leaderboardList" style="display:flex;flex-direction:column;gap:6px;">
          <div style="opacity:.7;">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
        </div>

        <!-- âœ… Top10ì´ë©´ ì´ë¦„ ì €ì¥ -->
        <div id="saveNameBox" style="display:none;margin-top:10px;">
          <div style="font-weight:900;margin-bottom:6px;">ğŸ‰ TOP10 ì§„ì…! ì´ë¦„ ì €ì¥</div>
          <div style="display:flex;gap:8px;">
            <input id="nameInput" maxlength="12" placeholder="ì´ë¦„/ë‹‰ë„¤ì„ (ìµœëŒ€ 12ì)"
              style="flex:1;padding:12px 12px;border-radius:12px;border:1px solid rgba(0,0,0,0.12);
                     font-weight:800;outline:none;" />
            <button id="saveNameBtn" type="button"
              style="padding:12px 14px;border-radius:12px;border:0;cursor:pointer;
                     font-weight:1000;color:#fff;background:#111;">
              ì €ì¥
            </button>
          </div>
          <div style="margin-top:6px;font-size:12px;opacity:.7;">â€» Top10ì— ë“¤ì—ˆì„ ë•Œë§Œ ì €ì¥í•  ìˆ˜ ìˆì–´ìš”</div>
        </div>
      </div>

      <!-- âœ… ë²„íŠ¼ì€ ì ìˆ˜íŒ ì•„ë˜ -->
      <button class="btn" id="restartBtn">ë‹¤ì‹œí•˜ê¸°</button>
      <button class="btn secondary" id="goBtn">ì“´ë§› ë™í™”ì±… ë³´ëŸ¬ê°€ê¸°</button>

      <div class="sub">
        ì†ê°€ë½ì„ í„°ì¹˜í•˜ë©´ +10ì <br/>
        ì†ê°€ë½ì´ ì…ì— ë‹¿ìœ¼ë©´ Game Over
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const BOOK_URL = 'https://smartstore.naver.com/bitterbooks/';
  const API_BASE = 'https://bitterbooks-score-api.kunmuk2025.workers.dev';
  const LB_LIMIT = 10;

  const canvas = document.getElementById('c');
  const scoreChip = document.getElementById('scoreChip');
  const hintChip  = document.getElementById('hintChip');
  const overlay   = document.getElementById('overlay');
  const startOverlay = document.getElementById('startOverlay');
  const startBtn = document.getElementById('startBtn');
  const finalScoreEl = document.getElementById('finalScore');
  const restartBtn = document.getElementById('restartBtn');
  const goBtn = document.getElementById('goBtn');
  const soundBtn = document.getElementById('soundBtn');

  const leaderboardList = document.getElementById('leaderboardList');
  const saveNameBox = document.getElementById('saveNameBox');
  const nameInput = document.getElementById('nameInput');
  const saveNameBtn = document.getElementById('saveNameBtn');

  const ctx = canvas.getContext('2d', { alpha: false });
  if (!ctx) {
    overlay.style.display = 'flex';
    finalScoreEl.textContent = 'ìº”ë²„ìŠ¤ ì´ˆê¸°í™” ì‹¤íŒ¨ (ë¸Œë¼ìš°ì € í˜¸í™˜ ë¬¸ì œ)';
    return;
  }

  // ===== util =====
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a,b)=>a+Math.random()*(b-a);

  function resize() {
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const w = Math.floor(window.innerWidth * dpr);
    const h = Math.floor(window.innerHeight * dpr);
    canvas.width = w;
    canvas.height = h;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    state.dpr = dpr;
  }
  window.addEventListener('resize', resize, { passive: true });

  function loadImg(src) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve({ img, ok: true });
      img.onerror = () => resolve({ img: null, ok: false });
      img.src = src;
    });
  }

  function escapeHtml(s='') {
    return String(s).replace(/[&<>"']/g, (m) => ({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
    }[m]));
  }

  function normalizeName(raw) {
    const n = (raw || '').trim();
    if (!n) return '';
    return n.length > 12 ? n.slice(0, 12) : n;
  }

  function renderLeaderboard(items, myId=null) {
    if (!leaderboardList) return;
    if (!items || items.length === 0) {
      leaderboardList.innerHTML = `<div style="opacity:.7;">ì•„ì§ ê¸°ë¡ì´ ì—†ì–´ìš”</div>`;
      return;
    }

    leaderboardList.innerHTML = items.slice(0, LB_LIMIT).map((it, idx) => {
      const name = escapeHtml(it.name ?? 'ìµëª…');
      const score = Number(it.score ?? 0);
      const rank = idx + 1;
      const isMe = myId && it.id === myId;

      return `
        <div style="display:flex;justify-content:space-between;align-items:center;
                    padding:8px 10px;border-radius:12px;
                    background:${isMe ? 'rgba(255, 235, 59, 0.35)' : 'rgba(255,255,255,0.7)'};
                    border:1px solid rgba(0,0,0,0.05);">
          <div style="font-weight:900;">${rank}ìœ„ Â· ${name}${isMe ? ' (ë‚˜)' : ''}</div>
          <div style="font-weight:1000;">${score.toLocaleString()}ì </div>
        </div>
      `;
    }).join('');
  }

  // âœ… ë™ì ë„ Top10 ì¸ì •
  function isTop10(score, items) {
    if (!items) return false;
    if (items.length < 10) return true;
    const last = Number(items[items.length - 1]?.score ?? -Infinity);
    return score >= last;
  }

  // ===== server calls (ë ˆì´ìŠ¤ ì œê±° ë²„ì „) =====
  // âœ… ì´ë²ˆ ê²Œì„ì˜ ì ìˆ˜ IDëŠ” currentScoreIdë¡œë§Œ ê´€ë¦¬
  let currentScoreId = null;

  // âœ… submit ìš”ì²­ì´ ëŠ¦ê²Œ ëë‚˜ë„ ì´ì „ ê²°ê³¼ê°€ currentScoreIdë¥¼ ë®ì–´ì“°ì§€ ì•Šë„ë¡ í† í° ì‚¬ìš©
  let submitToken = 0;

  // âœ… ì´ë¦„ ì €ì¥ ì¤‘ë³µ í´ë¦­ ë°©ì§€
  let savingName = false;

  async function submitScore(score) {
    const token = ++submitToken;
    currentScoreId = null;

    try {
      const res = await fetch(`${API_BASE}/score`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: 'ìµëª…', score }),
      });
      if (!res.ok) throw new Error('submit failed');
      const data = await res.json();
      // âœ… ê°€ì¥ ìµœì‹  submitë§Œ ìœ íš¨
      if (token === submitToken) {
        currentScoreId = data.id ?? null;
      }
      return currentScoreId;
    } catch (_) {
      if (token === submitToken) currentScoreId = null;
      return null;
    }
  }

  async function fetchLeaderboard() {
    if (!leaderboardList) return [];
    leaderboardList.innerHTML = `<div style="opacity:.7;">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>`;
    try {
      const res = await fetch(`${API_BASE}/leaderboard?limit=${LB_LIMIT}`, { method: 'GET' });
      if (!res.ok) throw new Error('leaderboard fetch failed');
      const data = await res.json();
      const items = data.items ?? data ?? [];
      renderLeaderboard(items, currentScoreId);
      return items;
    } catch (_) {
      leaderboardList.innerHTML = `<div style="opacity:.7;">ì ìˆ˜íŒì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆì–´ìš”</div>`;
      return [];
    }
  }

  async function saveName(name) {
    if (!currentScoreId) return false;
    try {
      const res = await fetch(`${API_BASE}/score/${encodeURIComponent(currentScoreId)}/name`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name }),
      });
      return res.ok;
    } catch (_) {
      return false;
    }
  }

  function resetLeaderboardUI() {
    // âœ… ìƒˆ ê²Œì„ ì‹œì‘ ì‹œ, ì´ì „ submit ê²°ê³¼ê°€ ë®ì–´ì“°ì§€ ëª»í•˜ê²Œ í† í° ì¦ê°€
    submitToken++;

    currentScoreId = null;
    savingName = false;

    if (leaderboardList) leaderboardList.innerHTML = `<div style="opacity:.7;">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>`;
    if (saveNameBox) saveNameBox.style.display = 'none';
    if (saveNameBtn) { saveNameBtn.textContent = 'ì €ì¥'; saveNameBtn.disabled = false; }
    if (nameInput) nameInput.value = localStorage.getItem('bb_name') || '';
  }

  // ===== audio =====
  const audio = { enabled:true, started:false, bgm:null, hit:null, ctx:null };

  function setSoundUi(){ soundBtn.textContent = audio.enabled ? 'ğŸ”Š' : 'ğŸ”‡'; }
  function tryCreateMediaAudio() {
    if (!audio.bgm) { audio.bgm = new Audio('bgm.mp3'); audio.bgm.loop = true; audio.bgm.volume = 0.25; audio.bgm.preload = 'auto'; }
    if (!audio.hit) { audio.hit = new Audio('hit.mp3'); audio.hit.volume = 0.7; audio.hit.preload = 'auto'; }
  }
  function ensureAudioContext() {
    if (audio.ctx) return audio.ctx;
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return null;
    audio.ctx = new AC();
    return audio.ctx;
  }
  function beep(freq=880, dur=0.06, type='square', gain=0.12) {
    if (!audio.enabled) return;
    const ac = ensureAudioContext();
    if (!ac) return;
    if (ac.state === 'suspended') ac.resume().catch(()=>{});
    const t0 = ac.currentTime;
    const osc = ac.createOscillator();
    const g = ac.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    osc.connect(g); g.connect(ac.destination);
    osc.start(t0); osc.stop(t0 + dur + 0.02);
  }
  async function startBgmIfPossible() {
    if (!audio.enabled || audio.started) return;
    tryCreateMediaAudio();
    audio.started = true;
    if (audio.bgm) { try { await audio.bgm.play(); return; } catch(_) {} }
    const ac = ensureAudioContext();
    if (!ac) return;
    if (ac.state === 'suspended') { try { await ac.resume(); } catch(_){} }
    const pattern = [392, 523.25];
    let idx = 0;
    const tick = () => {
      if (!audio.enabled || !state.running) return;
      beep(pattern[idx % pattern.length], 0.08, 'sine', 0.04);
      idx++;
      setTimeout(tick, 520);
    };
    tick();
  }
  function playHitSound() {
    if (!audio.enabled) return;
    tryCreateMediaAudio();
    if (audio.hit) {
      try {
        const node = audio.hit.cloneNode();
        node.volume = 0.7;
        node.play().catch(()=>{ beep(880, 0.06, 'square', 0.12); });
        return;
      } catch (_) {}
    }
    beep(880, 0.06, 'square', 0.12);
  }
  function stopBgm() {
    if (audio.bgm) { try { audio.bgm.pause(); audio.bgm.currentTime = 0; } catch(_){ } }
  }
  soundBtn.addEventListener('click', (e) => {
    e.preventDefault();
    audio.enabled = !audio.enabled;
    setSoundUi();
    if (!audio.enabled) { stopBgm(); }
    else { audio.started = false; if (state.running) startBgmIfPossible(); }
  });
  setSoundUi();

  // ===== assets =====
  const assets = {
    mouth: { img: null, ok: false, src: 'mouth.png' },
    finger:{ img: null, ok: false, src: 'finger.png' },
    inom:  { img: null, ok: false, src: 'inom.png' },
  };

  // ===== state =====
  const state = {
    dpr: 1,
    running: false,
    gameOver: false,
    score: 0,

    spawnTimer: 0,
    spawnEvery: 650,
    minSpawnEvery: 240,

    speedMin: 44,
    speedMax: 136,

    enemies: [],
    effects: [],

    lastTs: 0,
    center: { x: 0, y: 0 },

    mouthRadius: 92,
    dangerLevel: 0,
    camShake: { x:0, y:0, mag:0 },
    nearThreshold: 190,

    hitShakeKick: 14,
    hitShakeJitter: 8,

    elapsed: 0,
    rampDelay: 10000,
  };

  function resetGameToIdle() {
    state.running = false;
    state.gameOver = false;
    state.score = 0;

    state.spawnTimer = 0;
    state.spawnEvery = 650;
    state.speedMin = 44;
    state.speedMax = 136;

    state.enemies.length = 0;
    state.effects.length = 0;

    state.dangerLevel = 0;
    state.camShake = { x:0, y:0, mag:0 };
    state.elapsed = 0;

    scoreChip.textContent = `ì ìˆ˜: ${state.score}`;
    hintChip.textContent = 'ì‹œì‘í•˜ê¸°ë¥¼ ëˆŒëŸ¬ì£¼ì„¸ìš”';

    overlay.style.display = 'none';
    startOverlay.style.display = 'flex';

    stopBgm();
    audio.started = false;

    resetLeaderboardUI();

    state.lastTs = performance.now();
  }

  function startGame() {
    state.running = true;
    state.gameOver = false;

    state.score = 0;
    state.spawnTimer = 0;
    state.spawnEvery = 650;

    state.speedMin = 44;
    state.speedMax = 136;

    state.enemies.length = 0;
    state.effects.length = 0;

    state.dangerLevel = 0;
    state.camShake = { x:0, y:0, mag:0 };
    state.elapsed = 0;

    scoreChip.textContent = `ì ìˆ˜: ${state.score}`;
    hintChip.textContent = 'ì†ê°€ë½ì„ í„°ì¹˜!';

    startOverlay.style.display = 'none';
    overlay.style.display = 'none';

    resetLeaderboardUI();

    startBgmIfPossible();
    state.lastTs = performance.now();
  }

  function endGame() {
    state.running = false;
    state.gameOver = true;

    finalScoreEl.textContent = `ìµœì¢… ì ìˆ˜: ${state.score}`;
    overlay.style.display = 'flex';
    hintChip.textContent = 'ê²Œì„ ì˜¤ë²„';

    stopBgm();
    audio.started = false;

    const myScore = state.score;
    const localToken = ++submitToken; // âœ… ì´ë²ˆ ê²Œì„ í† í°(ì´í›„ ê²°ê³¼ê°€ ë’¤ì§‘íˆë©´ ë¬´ì‹œ)

    (async () => {
      // ì ìˆ˜ ë“±ë¡(ìµœì‹  í† í°ë§Œ currentScoreId ì„¸íŒ…ë¨)
      await submitScore(myScore);
      if (localToken !== submitToken) return;

      const items = await fetchLeaderboard();
      if (localToken !== submitToken) return;

      if (isTop10(myScore, items)) {
        saveNameBox.style.display = 'block';

        // ë²„íŠ¼ ìƒíƒœ ì´ˆê¸°í™”
        savingName = false;
        saveNameBtn.textContent = 'ì €ì¥';
        saveNameBtn.disabled = false;

        const saved = localStorage.getItem('bb_name') || '';
        nameInput.value = saved;
        nameInput.focus();
      } else {
        saveNameBox.style.display = 'none';
      }
    })();
  }

  function getCanvasPointFromEvent(e) {
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches && e.touches[0] ? e.touches[0] : null;
    const clientX = touch ? touch.clientX : e.clientX;
    const clientY = touch ? touch.clientY : e.clientY;
    return { x: (clientX - rect.left) * state.dpr, y: (clientY - rect.top) * state.dpr };
  }

  function spawnEnemy() {
    const w = canvas.width, h = canvas.height;
    const edge = (Math.random() * 4) | 0;
    let x, y;
    const pad = 30 * state.dpr;

    if (edge === 0) { x = rand(0, w); y = -pad; }
    else if (edge === 1) { x = w + pad; y = rand(0, h); }
    else if (edge === 2) { x = rand(0, w); y = h + pad; }
    else { x = -pad; y = rand(0, h); }

    const cx = state.center.x, cy = state.center.y;
    const dx = cx - x, dy = cy - y;
    const len = Math.hypot(dx, dy) || 1;

    const speed = rand(state.speedMin, state.speedMax) * state.dpr;
    const vx = (dx / len) * speed;
    const vy = (dy / len) * speed;

    const r = 22 * state.dpr;
    state.enemies.push({ x, y, vx, vy, r, alive:true });
  }

  function addEffect(x, y) { state.effects.push({ x, y, ttl: 500, total: 500 }); }
  function hitTestCircle(px, py, cx, cy, r) { const dx = px - cx, dy = py - cy; return (dx*dx + dy*dy) <= r*r; }

  function applyHitShake() {
    const kick = state.hitShakeKick * state.dpr;
    const jitter = state.hitShakeJitter * state.dpr;
    state.camShake.mag = Math.max(state.camShake.mag, kick);
    state.camShake.x += (Math.random() - 0.5) * jitter;
    state.camShake.y += (Math.random() - 0.5) * jitter;
  }

  function handlePointer(e) {
    if (!state.running) return;
    e.preventDefault();

    const p = getCanvasPointFromEvent(e);

    let hitIndex = -1;
    for (let i = state.enemies.length - 1; i >= 0; i--) {
      const en = state.enemies[i];
      if (!en.alive) continue;
      if (hitTestCircle(p.x, p.y, en.x, en.y, en.r * 1.25)) { hitIndex = i; break; }
    }

    if (hitIndex >= 0) {
      const en = state.enemies[hitIndex];
      en.alive = false;
      addEffect(en.x, en.y);
      applyHitShake();
      playHitSound();
      state.score += 10;
      scoreChip.textContent = `ì ìˆ˜: ${state.score}`;
      hintChip.textContent = 'ì˜í–ˆì–´!';
    }
  }

  canvas.addEventListener('touchstart', handlePointer, { passive:false });
  canvas.addEventListener('mousedown', handlePointer);

  startBtn.addEventListener('click', (e) => { e.preventDefault(); startGame(); });
  restartBtn.addEventListener('click', (e) => { e.preventDefault(); startGame(); });
  goBtn.addEventListener('click', () => { window.location.href = BOOK_URL; });

  // âœ… Top10 ì´ë¦„ ì €ì¥ ë²„íŠ¼
  saveNameBtn.addEventListener('click', async () => {
    const name = normalizeName(nameInput.value);
    if (!name) return;
    if (savingName) return;

    savingName = true;
    saveNameBtn.textContent = 'ì €ì¥ì¤‘...';
    saveNameBtn.disabled = true;

    try {
      const ok = await saveName(name);
      if (ok) {
        localStorage.setItem('bb_name', name);
        await fetchLeaderboard();
        saveNameBox.style.display = 'none';
      } else {
        alert('ì €ì¥ì— ì‹¤íŒ¨í–ˆì–´ìš”. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.');
      }
    } finally {
      savingName = false;
      saveNameBtn.textContent = 'ì €ì¥';
      saveNameBtn.disabled = false;
    }
  });

  // ===== draw =====
  function drawBackground(d) {
    const w = canvas.width, h = canvas.height;
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, w, h);
    ctx.restore();

    if (d > 0.02 && state.running) {
      ctx.save();
      ctx.globalAlpha = 0.06 * d;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, w, h);
      ctx.restore();
    }
  }

  function drawMouthAt(cx, cy, scaleMul) {
    const r = state.mouthRadius * state.dpr;
    const scale = scaleMul || 1;
    const plateR = r * 1.25 * scale;

    ctx.save();
    ctx.globalAlpha = 0.16;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(cx, cy + 10*state.dpr*scale, plateR*1.05, plateR*0.72, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.fillStyle = '#fff7e6';
    ctx.beginPath();
    ctx.arc(cx, cy, plateR, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,183,3,0.45)';
    ctx.lineWidth = Math.max(3, 3 * state.dpr);
    ctx.stroke();
    ctx.restore();

    if (assets.mouth.ok && assets.mouth.img) {
      const img = assets.mouth.img;
      const size = r * 4.0 * scale;
      ctx.drawImage(img, cx - size/2, cy - size/2, size, size);
    } else {
      const size = r * 3.6 * scale;
      ctx.fillStyle = '#1f9dff';
      ctx.fillRect(cx - size/2, cy - size/2, size, size);
    }
  }

  function drawFinger(en) {
    const scale = 3.4;
    if (assets.finger.ok && assets.finger.img) {
      const img = assets.finger.img;
      const size = en.r * scale;
      const angle = Math.atan2(en.vy, en.vx);
      ctx.save();
      ctx.translate(en.x, en.y);
      ctx.rotate(angle);
      ctx.globalAlpha = 1;
      ctx.drawImage(img, -size/2, -size/2, size, size);
      ctx.restore();
    } else {
      ctx.fillStyle = '#ff3d3d';
      ctx.beginPath();
      ctx.arc(en.x, en.y, en.r*1.25, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawEffect(ef) {
    const t = ef.ttl / ef.total;
    const alpha = clamp(t, 0, 1);
    ctx.save();
    ctx.globalAlpha = alpha;
    const base = 56 * state.dpr * (1 + (1-t)*0.15);
    if (assets.inom.ok && assets.inom.img) {
      ctx.drawImage(assets.inom.img, ef.x - base/2, ef.y - base/2, base, base);
    } else {
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(ef.x, ef.y, 16*state.dpr, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function computeDangerLevel() {
    const cx = state.center.x, cy = state.center.y;
    let minD = Infinity;
    for (const en of state.enemies) {
      if (!en.alive) continue;
      const d = Math.hypot(en.x - cx, en.y - cy);
      if (d < minD) minD = d;
    }
    if (!isFinite(minD)) return 0;
    const threshold = state.nearThreshold * state.dpr;
    const mouthR = state.mouthRadius * state.dpr * 0.85;
    const t = (threshold - minD) / Math.max(1, (threshold - mouthR));
    return clamp(t, 0, 1);
  }

  function updateCameraShake(dt) {
    const d = state.dangerLevel;
    const baseMag = (3 + 20 * d * d) * state.dpr;
    state.camShake.mag = lerp(state.camShake.mag, baseMag, 0.10);
    const jitter = (0.6 + 1.6 * d) * (dt / 16.67);
    state.camShake.x = lerp(state.camShake.x, (Math.random() - 0.5) * state.camShake.mag, 0.22 * jitter);
    state.camShake.y = lerp(state.camShake.y, (Math.random() - 0.5) * state.camShake.mag, 0.22 * jitter);
    if (d < 0.02) { state.camShake.x *= 0.86; state.camShake.y *= 0.86; state.camShake.mag *= 0.92; }
    else { state.camShake.mag *= 0.985; }
  }

  function update(dt) {
    state.elapsed += dt;
    state.spawnTimer += dt;

    while (state.spawnTimer >= state.spawnEvery) {
      state.spawnTimer -= state.spawnEvery;
      spawnEnemy();
      if (state.elapsed >= state.rampDelay) {
        state.spawnEvery = Math.max(state.minSpawnEvery, state.spawnEvery - 4);
        state.speedMin = Math.min(104, state.speedMin + 0.18);
        state.speedMax = Math.min(208, state.speedMax + 0.28);
      }
    }

    for (const en of state.enemies) {
      if (!en.alive) continue;
      en.x += en.vx * (dt / 1000);
      en.y += en.vy * (dt / 1000);
    }
    for (const ef of state.effects) ef.ttl -= dt;

    state.enemies = state.enemies.filter(en => en.alive);
    state.effects = state.effects.filter(ef => ef.ttl > 0);

    state.dangerLevel = computeDangerLevel();
    updateCameraShake(dt);

    const cx = state.center.x, cy = state.center.y;
    const mouthR = state.mouthRadius * state.dpr * 0.85;
    for (const en of state.enemies) {
      const rr = en.r + mouthR;
      const dx = en.x - cx, dy = en.y - cy;
      if ((dx*dx + dy*dy) <= rr*rr) {
        state.dangerLevel = 1;
        state.camShake.mag = Math.max(state.camShake.mag, 26 * state.dpr);
        endGame();
        break;
      }
    }
  }

  function render() {
    state.center.x = canvas.width / 2;
    state.center.y = canvas.height / 2;

    ctx.save();
    ctx.translate(state.camShake.x, state.camShake.y);

    drawBackground(state.dangerLevel);
    const mouthScale = 1.0 + 0.72 * (state.dangerLevel ** 1.6);
    drawMouthAt(state.center.x, state.center.y, mouthScale);

    for (const en of state.enemies) drawFinger(en);
    for (const ef of state.effects) drawEffect(ef);

    ctx.restore();
  }

  function loop(ts) {
    const dt = Math.min(34, ts - state.lastTs);
    state.lastTs = ts;
    if (state.running) update(dt);
    render();
    requestAnimationFrame(loop);
  }

  async function boot() {
    resize();
    const [m, f, i] = await Promise.all([
      loadImg(assets.mouth.src),
      loadImg(assets.finger.src),
      loadImg(assets.inom.src),
    ]);
    assets.mouth.img = m.img; assets.mouth.ok = m.ok;
    assets.finger.img = f.img; assets.finger.ok = f.ok;
    assets.inom.img = i.img; assets.inom.ok = i.ok;

    resetGameToIdle();
    requestAnimationFrame((t) => { state.lastTs = t; loop(t); });
  }

  boot();
})();
</script>
</body>
</html>
