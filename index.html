<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <!-- ì¸ì•± ë¸Œë¼ìš°ì €/ëª¨ë°”ì¼ ì•ˆì •ì„±(íŠ¹íˆ iOS) -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="format-detection" content="telephone=no" />

  <title>ì†ê°€ë½ ë¹¨ê¸° STOP! ë†€ì´ë¡œ ë©ˆì¶”ëŠ” ê²Œì„</title>
  <style>
    :root{
      --ink:#1f1f1f;
      --panel:rgba(255,255,255,0.90);
      --shadow:rgba(0,0,0,0.16);
      --btn:#ff6b6b;
    }

    /* âœ… iOS ì•ˆì „ì˜ì—­/ì¸ì•± ë¸Œë¼ìš°ì €ì—ì„œ ì¤‘ì•™ì •ë ¬ì´ í‹€ì–´ì§€ëŠ” ë¬¸ì œ ë°©ì§€ */
    *{ box-sizing:border-box; }

    html,body{
      height:100%;
      margin:0;
      background:#ffffff;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",Arial,sans-serif;
      color:var(--ink);
      overscroll-behavior:none;
      touch-action:none;
    }

    #wrap{position:relative;height:100%;width:100%;}
    canvas{width:100vw;height:100vh;display:block;background:#ffffff;}

    .hud{
      position:absolute;
      top: env(safe-area-inset-top, 0px);
      left: env(safe-area-inset-left, 0px);
      right: env(safe-area-inset-right, 0px);
      padding:10px 14px;
      display:flex;justify-content:space-between;align-items:center;
      pointer-events:none;user-select:none;
      font-weight:1000;letter-spacing:-0.2px;
      text-shadow:0 1px 0 rgba(255,255,255,0.8);
      gap:10px;
    }
    .hudRight{display:flex;gap:10px;align-items:center;justify-content:flex-end;}

    .chip{
      background:rgba(255,255,255,0.78);
      border-radius:999px;
      padding:8px 12px;
      box-shadow:0 6px 16px var(--shadow);
      border:1px solid rgba(0,0,0,0.06);
      pointer-events:none;
      white-space:nowrap;
    }

    /* âœ… ì‚¬ìš´ë“œ í† ê¸€ ë²„íŠ¼(ì¸ì•± ë¸Œë¼ìš°ì €ì—ì„œë„ í´ë¦­ ê°€ëŠ¥) */
    .iconBtn{
      pointer-events:auto;
      border:1px solid rgba(0,0,0,0.08);
      background:rgba(255,255,255,0.78);
      border-radius:999px;
      padding:8px 10px;
      box-shadow:0 6px 16px var(--shadow);
      font-weight:900;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .iconBtn:active{transform:translateY(1px);}

    /* âœ… ì´ˆê¸° ê°€ì´ë“œ ë¬¸êµ¬ */
    .intro{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      padding:
        calc(16px + env(safe-area-inset-top, 0px))
        calc(16px + env(safe-area-inset-right, 0px))
        calc(16px + env(safe-area-inset-bottom, 0px))
        calc(16px + env(safe-area-inset-left, 0px));
    }
    .introCard{
      background:rgba(255,255,255,0.88);
      padding:14px 18px;
      border-radius:16px;
      box-shadow:0 10px 24px rgba(0,0,0,0.15);
      text-align:center;
      max-width:min(520px,92vw);
    }
    .introTitle{font-size:18px;font-weight:900;}
    .introSub{margin-top:6px;font-size:14px;opacity:0.85;}

    .overlay{
      position:absolute;
      inset:0;
      display:none;
      /* âœ… flex ì¤‘ì•™ì •ë ¬(ì¸ì•± ë¸Œë¼ìš°ì €ì—ì„œ ì•ˆì •ì ) */
      align-items:center;
      justify-content:center;
      /* âœ… ì•ˆì „ì˜ì—­ í¬í•¨ íŒ¨ë”©: ë…¸ì¹˜/í™ˆë°” í™˜ê²½ì—ì„œë„ ì‹œê°ìƒ ì¤‘ì•™ */
      padding:
        calc(18px + env(safe-area-inset-top, 0px))
        calc(18px + env(safe-area-inset-right, 0px))
        calc(18px + env(safe-area-inset-bottom, 0px))
        calc(18px + env(safe-area-inset-left, 0px));
      background:rgba(0,0,0,0.16);
    }

    .panel{
      width:min(520px,92vw);
      border-radius:22px;
      background:var(--panel);
      box-shadow:0 18px 40px var(--shadow);
      padding:18px 16px 16px;
      text-align:center;
    }
    .panel h1{margin:6px 0 8px;font-size:22px;letter-spacing:-0.4px;}
    .panel p{margin:8px 0 14px;font-size:15px;opacity:0.92;}

    .btn{
      appearance:none;border:0;border-radius:16px;
      padding:14px 16px;width:100%;
      font-size:18px;font-weight:1000;
      cursor:pointer;
      box-shadow:0 12px 24px var(--shadow);
      color:#fff;
      background:linear-gradient(135deg,var(--btn) 0%, #ff3d3d 100%);
    }
    .btn.secondary{
      margin-top:10px;
      background:linear-gradient(135deg,#ffb703 0%, #fb8500 100%);
    }
    .btn:active{transform:translateY(1px);}

    .sub{margin-top:10px;font-size:13px;opacity:0.75;line-height:1.4;}
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="chip" id="scoreChip">ì ìˆ˜: 0</div>
    <div class="hudRight">
      <div class="chip" id="hintChip">ì†ê°€ë½ì„ í„°ì¹˜!</div>
      <button class="iconBtn" id="soundBtn" type="button" aria-label="ì‚¬ìš´ë“œ í† ê¸€">ğŸ”Š</button>
    </div>
  </div>

  <div class="intro" id="introGuide" aria-hidden="true">
    <div class="introCard">
      <div class="introTitle">ì†ê°€ë½ì´ ì…ì— ë‹¿ê¸° ì „ì— ë§‰ì•„ì¤˜!</div>
      <div class="introSub">(ì†ê°€ë½ì„ í„°ì¹˜í•˜ë©´ ì‚¬ë¼ì ¸ìš”)</div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="panel">
      <h1>ìœ¼~ ë„ˆë¬´ ì¨!</h1>
      <p id="finalScore">ìµœì¢… ì ìˆ˜: 0</p>
      <button class="btn" id="restartBtn">ë‹¤ì‹œí•˜ê¸°</button>
      <button class="btn secondary" id="goBtn">ì“´ë§› ë™í™”ì±… ë³´ëŸ¬ê°€ê¸°</button>
      <div class="sub">
        í„°ì¹˜/í´ë¦­ìœ¼ë¡œ ì†ê°€ë½ì„ ì¡ìœ¼ë©´ +10ì <br/>
        ì†ê°€ë½ì´ ì…ì— ë‹¿ìœ¼ë©´ ê²Œì„ ì˜¤ë²„
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // âœ… ìŠ¤ë§ˆíŠ¸ìŠ¤í† ì–´/ë¸”ë¡œê·¸ URL
  const BOOK_URL = 'https://smartstore.naver.com/bitterbooks/';

  // âœ… (ì„ íƒ) ì‹¤ì œ ì‚¬ìš´ë“œ íŒŒì¼ì„ ì“°ë ¤ë©´ ê°™ì€ í´ë”ì— ì•„ë˜ íŒŒì¼ì„ ì˜¬ë¦¬ì„¸ìš”.
  // - bgm.mp3 (ë°°ê²½ìŒì•…)
  // - hit.mp3 (í„°ì¹˜ íƒ€ê²©ìŒ)
  // íŒŒì¼ì´ ì—†ìœ¼ë©´ ìë™ìœ¼ë¡œ "ê°„ë‹¨í•œ ë¹„í”„ìŒ"ìœ¼ë¡œ ëŒ€ì²´ë©ë‹ˆë‹¤.

  const canvas = document.getElementById('c');
  const scoreChip = document.getElementById('scoreChip');
  const hintChip  = document.getElementById('hintChip');
  const overlay   = document.getElementById('overlay');
  const introGuide = document.getElementById('introGuide');
  const finalScoreEl = document.getElementById('finalScore');
  const restartBtn = document.getElementById('restartBtn');
  const goBtn = document.getElementById('goBtn');
  const soundBtn = document.getElementById('soundBtn');

  const ctx = canvas.getContext('2d', { alpha: false });
  if (!ctx) {
    overlay.style.display = 'flex';
    finalScoreEl.textContent = 'ìº”ë²„ìŠ¤ ì´ˆê¸°í™” ì‹¤íŒ¨ (ë¸Œë¼ìš°ì € í˜¸í™˜ ë¬¸ì œ)';
    return;
  }

  // ===== util =====
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a,b)=>a+Math.random()*(b-a);

  function resize() {
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const w = Math.floor(window.innerWidth * dpr);
    const h = Math.floor(window.innerHeight * dpr);
    canvas.width = w;
    canvas.height = h;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    state.dpr = dpr;
  }
  window.addEventListener('resize', resize, { passive: true });

  function loadImg(src) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve({ img, ok: true });
      img.onerror = () => resolve({ img: null, ok: false });
      img.src = src;
    });
  }

  // ===== audio =====
  const audio = {
    enabled: true,
    started: false,
    bgm: null,
    hit: null,
    ctx: null,
  };

  function setSoundUi() {
    soundBtn.textContent = audio.enabled ? 'ğŸ”Š' : 'ğŸ”‡';
  }

  function tryCreateMediaAudio() {
    // íŒŒì¼ì´ ì—†ìœ¼ë©´ playê°€ ì‹¤íŒ¨í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ì‹¤íŒ¨ ì‹œ WebAudio ë¹„í”„ìŒìœ¼ë¡œ ëŒ€ì²´
    if (!audio.bgm) {
      audio.bgm = new Audio('bgm.mp3');
      audio.bgm.loop = true;
      audio.bgm.volume = 0.25;
      audio.bgm.preload = 'auto';
    }
    if (!audio.hit) {
      audio.hit = new Audio('hit.mp3');
      audio.hit.volume = 0.7;
      audio.hit.preload = 'auto';
    }
  }

  function ensureAudioContext() {
    if (audio.ctx) return audio.ctx;
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return null;
    audio.ctx = new AC();
    return audio.ctx;
  }

  function beep(freq=880, dur=0.06, type='square', gain=0.12) {
    if (!audio.enabled) return;
    const ac = ensureAudioContext();
    if (!ac) return;
    if (ac.state === 'suspended') ac.resume().catch(()=>{});

    const t0 = ac.currentTime;
    const osc = ac.createOscillator();
    const g = ac.createGain();

    osc.type = type;
    osc.frequency.setValueAtTime(freq, t0);

    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

    osc.connect(g);
    g.connect(ac.destination);

    osc.start(t0);
    osc.stop(t0 + dur + 0.02);
  }

  async function startBgmIfPossible() {
    if (!audio.enabled) return;
    if (audio.started) return;

    tryCreateMediaAudio();

    // ëª¨ë°”ì¼ì€ ì‚¬ìš©ì ì œìŠ¤ì²˜ê°€ ìˆì–´ì•¼ ì¬ìƒë¨ â†’ ìµœì´ˆ í„°ì¹˜ì—ì„œ í˜¸ì¶œ
    audio.started = true;

    // 1) mp3 ì‹œë„
    if (audio.bgm) {
      try {
        await audio.bgm.play();
        return;
      } catch (_) {
        // 2) WebAudioë¡œ "ì€ì€í•œ" ë°°ê²½ìŒ(ê°„ë‹¨ ë£¨í”„)ì„ í‰ë‚´
      }
    }

    // WebAudio ë°°ê²½ìŒ(ì§§ì€ íŒ¨í„´ì„ ë°˜ë³µ)
    const ac = ensureAudioContext();
    if (!ac) return;
    if (ac.state === 'suspended') { try { await ac.resume(); } catch(_){} }

    // ì•„ì£¼ ë‹¨ìˆœí•œ 2ìŒ ë°˜ë³µ
    const pattern = [392, 523.25]; // G4, C5
    let idx = 0;
    const tick = () => {
      if (!audio.enabled || !state.running) return;
      beep(pattern[idx % pattern.length], 0.08, 'sine', 0.04);
      idx++;
      setTimeout(tick, 520);
    };
    tick();
  }

  function playHitSound() {
    if (!audio.enabled) return;
    tryCreateMediaAudio();

    // mp3 íƒ€ê²©ìŒ ìš°ì„ 
    if (audio.hit) {
      try {
        const node = audio.hit.cloneNode();
        node.volume = 0.7;
        node.play().catch(()=>{ beep(880, 0.06, 'square', 0.12); });
        return;
      } catch (_) {
        // fallback
      }
    }
    beep(880, 0.06, 'square', 0.12);
  }

  function stopBgm() {
    if (audio.bgm) {
      try { audio.bgm.pause(); audio.bgm.currentTime = 0; } catch(_){}
    }
  }

  soundBtn.addEventListener('click', (e) => {
    e.preventDefault();
    audio.enabled = !audio.enabled;
    setSoundUi();
    if (!audio.enabled) {
      stopBgm();
    } else {
      // ë‹¤ì‹œ ì¼°ìœ¼ë©´ ë‹¤ìŒ ì‚¬ìš©ì ì…ë ¥ì—ì„œ ì‹œì‘ë˜ë„ë¡
      audio.started = false;
      // í´ë¦­ ìì²´ë„ ì œìŠ¤ì²˜ì´ë¯€ë¡œ ì¦‰ì‹œ ì‹œì‘ ì‹œë„
      startBgmIfPossible();
    }
  });

  setSoundUi();

  const assets = {
    mouth: { img: null, ok: false, src: 'mouth.png' },
    finger:{ img: null, ok: false, src: 'finger.png' },
    inom:  { img: null, ok: false, src: 'inom.png' },
  };

  // ===== state =====
  const state = {
    dpr: 1,
    running: false,
    gameOver: false,
    score: 0,

    spawnTimer: 0,
    spawnEvery: 650,
    minSpawnEvery: 240,

    // âœ… ì† ì†ë„ 0.4ë°°(ë” ëŠë¦¬ê²Œ)
    speedMin: 40,
    speedMax: 120,

    enemies: [],
    effects: [],

    lastTs: 0,
    center: { x: 0, y: 0 },

    // ì¤‘ì•™ ì´ë¯¸ì§€(ì…)
    mouthRadius: 92,

    // ê²Œì„ì˜¤ë²„ ì§ì „ ì—°ì¶œ
    dangerLevel: 0,
    camShake: { x:0, y:0, mag:0 },
    nearThreshold: 190,

    // íƒ€ê²©ê°(íˆíŠ¸) ì‰ì´í¬ ì„¤ì •
    hitShakeKick: 14,
    hitShakeJitter: 8,
  };

  let introHidden = false;

  function hideIntro() {
    if (introHidden) return;
    if (introGuide) introGuide.style.display = 'none';
    introHidden = true;
  }

  function resetGame() {
    state.running = true;
    state.gameOver = false;
    state.score = 0;

    state.spawnTimer = 0;
    state.spawnEvery = 650;

    // ì´ˆê¸° ì†ë„ë„ 0.4ë°°ë¡œ ë¦¬ì…‹
    state.speedMin = 40;
    state.speedMax = 120;

    state.enemies.length = 0;
    state.effects.length = 0;

    state.dangerLevel = 0;
    state.camShake = { x:0, y:0, mag:0 };

    scoreChip.textContent = `ì ìˆ˜: ${state.score}`;
    hintChip.textContent = 'ì†ê°€ë½ì„ í„°ì¹˜!';
    overlay.style.display = 'none';

    // ë‹¤ì‹œí•˜ê¸° ì‹œ ì¸íŠ¸ë¡œ ê°€ì´ë“œëŠ” ë‹¤ì‹œ ë³´ì´ê²Œ
    if (introGuide) introGuide.style.display = 'flex';
    introHidden = false;

    // ë°°ê²½ìŒì€ ë‹¤ìŒ ì‚¬ìš©ì ì…ë ¥ì—ì„œ ì‹œì‘(ëª¨ë°”ì¼ ì •ì±… ëŒ€ì‘)
    audio.started = false;

    state.lastTs = performance.now();
  }

  function endGame() {
    state.running = false;
    state.gameOver = true;
    finalScoreEl.textContent = `ìµœì¢… ì ìˆ˜: ${state.score}`;
    overlay.style.display = 'flex';
    hintChip.textContent = 'ê²Œì„ ì˜¤ë²„';

    // âœ… ê²Œì„ ëë‚˜ë©´ BGM ì •ì§€(ëŒ€í‘œë‹˜ ì„ íƒ: ê²Œì„ ì˜¤ë²„ ì‹œ ë©ˆì¶¤)
    stopBgm();
    audio.started = false;
  }

  function getCanvasPointFromEvent(e) {
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches && e.touches[0] ? e.touches[0] : null;
    const clientX = touch ? touch.clientX : e.clientX;
    const clientY = touch ? touch.clientY : e.clientY;
    return {
      x: (clientX - rect.left) * state.dpr,
      y: (clientY - rect.top) * state.dpr
    };
  }

  // ===== gameplay =====
  function spawnEnemy() {
    const w = canvas.width, h = canvas.height;
    const edge = (Math.random() * 4) | 0;
    let x, y;
    const pad = 30 * state.dpr;

    if (edge === 0) { x = rand(0, w); y = -pad; }
    else if (edge === 1) { x = w + pad; y = rand(0, h); }
    else if (edge === 2) { x = rand(0, w); y = h + pad; }
    else { x = -pad; y = rand(0, h); }

    const cx = state.center.x, cy = state.center.y;
    const dx = cx - x, dy = cy - y;
    const len = Math.hypot(dx, dy) || 1;

    const speed = rand(state.speedMin, state.speedMax) * state.dpr;
    const vx = (dx / len) * speed;
    const vy = (dy / len) * speed;

    const r = 22 * state.dpr;
    state.enemies.push({ x, y, vx, vy, r, alive:true });
  }

  function addEffect(x, y) {
    state.effects.push({ x, y, ttl: 500, total: 500 });
  }

  function hitTestCircle(px, py, cx, cy, r) {
    const dx = px - cx, dy = py - cy;
    return (dx*dx + dy*dy) <= r*r;
  }

  function applyHitShake() {
    const kick = state.hitShakeKick * state.dpr;
    const jitter = state.hitShakeJitter * state.dpr;
    state.camShake.mag = Math.max(state.camShake.mag, kick);
    state.camShake.x += (Math.random() - 0.5) * jitter;
    state.camShake.y += (Math.random() - 0.5) * jitter;
  }

  function handlePointer(e) {
    if (!state.running) return;
    e.preventDefault();

    // âœ… ëª¨ë°”ì¼ ì˜¤ë””ì˜¤ ì •ì±… ëŒ€ì‘: ìµœì´ˆ í„°ì¹˜ì— BGM ì‹œì‘
    startBgmIfPossible();

    // "ì†ê°€ë½ì„ í„°ì¹˜í•˜ë©´ ì‚¬ë¼ì ¸ìš”" â†’ ëª…ì¤‘ ì—¬ë¶€ì™€ ìƒê´€ì—†ì´ ì²« í„°ì¹˜ì— ê°€ì´ë“œ ì œê±°
    hideIntro();

    const p = getCanvasPointFromEvent(e);

    let hitIndex = -1;
    for (let i = state.enemies.length - 1; i >= 0; i--) {
      const en = state.enemies[i];
      if (!en.alive) continue;
      if (hitTestCircle(p.x, p.y, en.x, en.y, en.r * 1.25)) {
        hitIndex = i;
        break;
      }
    }

    if (hitIndex >= 0) {
      const en = state.enemies[hitIndex];
      en.alive = false;
      addEffect(en.x, en.y);
      applyHitShake();

      // âœ… íƒ€ê²©ìŒ
      playHitSound();

      state.score += 10;
      scoreChip.textContent = `ì ìˆ˜: ${state.score}`;
      hintChip.textContent = 'ì˜í–ˆì–´!';
    }
  }

  canvas.addEventListener('touchstart', handlePointer, { passive:false });
  canvas.addEventListener('mousedown', (e) => {
    // ë°ìŠ¤í¬íƒ‘ì—ì„œë„ ë™ì¼í•˜ê²Œ
    handlePointer(e);
  });

  restartBtn.addEventListener('click', () => {
    resetGame();
    // ë²„íŠ¼ í´ë¦­ë„ ì‚¬ìš©ì ì œìŠ¤ì²˜ì´ë¯€ë¡œ, ë°”ë¡œ BGM ì‹œì‘ ì‹œë„ ê°€ëŠ¥
    startBgmIfPossible();
  });

  goBtn.addEventListener('click', () => {
    // í•­ìƒ ê°™ì€ íƒ­ì—ì„œ ì´ë™
    window.location.href = BOOK_URL;
  });

  // ===== draw =====
  function drawBackground(d) {
    const w = canvas.width, h = canvas.height;
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, w, h);
    ctx.restore();

    if (d > 0.02 && state.running) {
      ctx.save();
      ctx.globalAlpha = 0.06 * d;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, w, h);
      ctx.globalCompositeOperation = 'destination-out';
      const rg = ctx.createRadialGradient(
        state.center.x, state.center.y, 140*state.dpr,
        state.center.x, state.center.y, 650*state.dpr
      );
      rg.addColorStop(0, 'rgba(0,0,0,0)');
      rg.addColorStop(1, 'rgba(0,0,0,1)');
      ctx.fillStyle = rg;
      ctx.fillRect(0, 0, w, h);
      ctx.restore();
      ctx.globalCompositeOperation = 'source-over';
    }
  }

  function drawMouthAt(cx, cy, scaleMul) {
    const r = state.mouthRadius * state.dpr;
    const scale = scaleMul || 1;

    const plateR = r * 1.25 * scale;

    ctx.save();
    ctx.globalAlpha = 0.16;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(cx, cy + 10*state.dpr*scale, plateR*1.05, plateR*0.72, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.fillStyle = '#fff7e6';
    ctx.beginPath();
    ctx.arc(cx, cy, plateR, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,183,3,0.45)';
    ctx.lineWidth = Math.max(3, 3 * state.dpr);
    ctx.stroke();
    ctx.restore();

    if (assets.mouth.ok && assets.mouth.img) {
      const img = assets.mouth.img;
      const size = r * 4.0 * scale;
      ctx.drawImage(img, cx - size/2, cy - size/2, size, size);
    } else {
      const size = r * 3.6 * scale;
      ctx.fillStyle = '#1f9dff';
      ctx.fillRect(cx - size/2, cy - size/2, size, size);
      ctx.strokeStyle = '#003a66';
      ctx.lineWidth = Math.max(3, 3 * state.dpr);
      ctx.beginPath();
      ctx.arc(cx, cy + size*0.15, size*0.28, 0, Math.PI, false);
      ctx.stroke();
    }

    return r;
  }

  function drawFinger(en) {
    const scale = 3.4;

    ctx.save();
    ctx.globalAlpha = 0.16;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(en.x + 6*state.dpr, en.y + 8*state.dpr, en.r*1.05, en.r*0.9, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    if (assets.finger.ok && assets.finger.img) {
      const img = assets.finger.img;
      const size = en.r * scale;
      const angle = Math.atan2(en.vy, en.vx);

      ctx.save();
      ctx.translate(en.x, en.y);
      ctx.rotate(angle);

      ctx.globalAlpha = 0.22;
      ctx.fillStyle = '#fff7e6';
      ctx.beginPath();
      ctx.arc(0, 0, (size*0.42), 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.45;
      ctx.strokeStyle = 'rgba(255,183,3,0.45)';
      ctx.lineWidth = Math.max(2, 2*state.dpr);
      ctx.stroke();

      ctx.globalAlpha = 1;
      ctx.drawImage(img, -size/2, -size/2, size, size);
      ctx.restore();
    } else {
      ctx.fillStyle = '#ff3d3d';
      ctx.beginPath();
      ctx.arc(en.x, en.y, en.r*1.25, 0, Math.PI*2);
      ctx.fill();

      ctx.strokeStyle = 'rgba(255,183,3,0.55)';
      ctx.lineWidth = Math.max(3, 3*state.dpr);
      ctx.stroke();

      ctx.fillStyle = 'rgba(255,255,255,0.55)';
      ctx.beginPath();
      ctx.arc(en.x - en.r*0.25, en.y - en.r*0.25, en.r*0.35, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawEffect(ef) {
    const t = ef.ttl / ef.total;
    const alpha = clamp(t, 0, 1);
    const pop = 1.0 + (1 - t) * 0.15;

    ctx.save();
    ctx.globalAlpha = alpha;

    const base = 56 * state.dpr * pop;

    if (assets.inom.ok && assets.inom.img) {
      ctx.drawImage(assets.inom.img, ef.x - base/2, ef.y - base/2, base, base);
    } else {
      ctx.fillStyle = '#111';
      ctx.beginPath();
      const spikes = 8;
      const outer = 18 * state.dpr * pop;
      const inner = 8 * state.dpr * pop;
      for (let i = 0; i < spikes * 2; i++) {
        const ang = (Math.PI / spikes) * i;
        const rr = (i % 2 === 0) ? outer : inner;
        const x = ef.x + Math.cos(ang) * rr;
        const y = ef.y + Math.sin(ang) * rr;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    }

    // íˆíŠ¸ í…ìŠ¤íŠ¸
    ctx.font = `${Math.floor(22 * state.dpr)}px system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.lineWidth = Math.max(4, 4 * state.dpr);
    ctx.strokeStyle = 'rgba(255,255,255,0.95)';
    ctx.fillStyle = '#111';
    const ty = ef.y + (38 * state.dpr);
    ctx.strokeText('Good!', ef.x, ty);
    ctx.fillText('Good!', ef.x, ty);

    ctx.restore();
  }

  function computeDangerLevel() {
    const cx = state.center.x, cy = state.center.y;
    let minD = Infinity;
    for (const en of state.enemies) {
      if (!en.alive) continue;
      const d = Math.hypot(en.x - cx, en.y - cy);
      if (d < minD) minD = d;
    }
    if (!isFinite(minD)) return 0;

    const threshold = state.nearThreshold * state.dpr;
    const mouthR = state.mouthRadius * state.dpr * 0.85;
    const t = (threshold - minD) / Math.max(1, (threshold - mouthR));
    return clamp(t, 0, 1);
  }

  function updateCameraShake(dt) {
    const d = state.dangerLevel;
    const baseMag = (3 + 20 * d * d) * state.dpr;

    state.camShake.mag = lerp(state.camShake.mag, baseMag, 0.10);

    const jitter = (0.6 + 1.6 * d) * (dt / 16.67);
    state.camShake.x = lerp(state.camShake.x, (Math.random() - 0.5) * state.camShake.mag, 0.22 * jitter);
    state.camShake.y = lerp(state.camShake.y, (Math.random() - 0.5) * state.camShake.mag, 0.22 * jitter);

    if (d < 0.02) {
      state.camShake.x *= 0.86;
      state.camShake.y *= 0.86;
      state.camShake.mag *= 0.92;
    } else {
      state.camShake.mag *= 0.985;
    }
  }

  function update(dt) {
    state.spawnTimer += dt;
    while (state.spawnTimer >= state.spawnEvery) {
      state.spawnTimer -= state.spawnEvery;
      spawnEnemy();

      state.spawnEvery = Math.max(state.minSpawnEvery, state.spawnEvery - 6);

      // ë‚œì´ë„ ì¦ê°€(ì†ë„ ì¦ê°€ëŸ‰ 0.4ë°°)
      state.speedMin = Math.min(104, state.speedMin + 0.24);
      state.speedMax = Math.min(208, state.speedMax + 0.36);
    }

    for (const en of state.enemies) {
      if (!en.alive) continue;
      en.x += en.vx * (dt / 1000);
      en.y += en.vy * (dt / 1000);
    }

    for (const ef of state.effects) ef.ttl -= dt;

    state.enemies = state.enemies.filter(en => en.alive);
    state.effects = state.effects.filter(ef => ef.ttl > 0);

    state.dangerLevel = computeDangerLevel();
    updateCameraShake(dt);

    const cx = state.center.x, cy = state.center.y;
    const mouthR = state.mouthRadius * state.dpr * 0.85;
    for (const en of state.enemies) {
      const rr = en.r + mouthR;
      const dx = en.x - cx, dy = en.y - cy;
      if ((dx*dx + dy*dy) <= rr*rr) {
        state.dangerLevel = 1;
        state.camShake.mag = Math.max(state.camShake.mag, 26 * state.dpr);
        endGame();
        break;
      }
    }
  }

  function render() {
    state.center.x = canvas.width / 2;
    state.center.y = canvas.height / 2;

    ctx.save();
    ctx.translate(state.camShake.x, state.camShake.y);

    drawBackground(state.dangerLevel);

    const mouthScale = 1.0 + 0.72 * (state.dangerLevel ** 1.6);
    drawMouthAt(state.center.x, state.center.y, mouthScale);

    for (const en of state.enemies) drawFinger(en);
    for (const ef of state.effects) drawEffect(ef);

    ctx.restore();
  }

  function loop(ts) {
    const dt = Math.min(34, ts - state.lastTs);
    state.lastTs = ts;
    if (state.running) update(dt);
    render();
    requestAnimationFrame(loop);
  }

  // ===== tests (ê°„ë‹¨ ëŸ°íƒ€ì„ ì²´í¬) =====
  function runSelfTests() {
    console.assert(document.getElementById('c') instanceof HTMLCanvasElement, 'Canvas element should exist');
    console.assert(document.querySelectorAll('#goBtn').length === 1, 'goBtn should be unique');
    console.assert(document.querySelectorAll('#hintChip').length === 1, 'hintChip must be unique (no duplicate IDs)');
    console.assert(typeof ctx.strokeText === 'function', 'Canvas context should be valid');
    console.assert(soundBtn instanceof HTMLButtonElement, 'soundBtn should exist');
  }

  // ===== boot =====
  async function boot() {
    resize();

    const [m, f, i] = await Promise.all([
      loadImg(assets.mouth.src),
      loadImg(assets.finger.src),
      loadImg(assets.inom.src),
    ]);
    assets.mouth.img = m.img; assets.mouth.ok = m.ok;
    assets.finger.img = f.img; assets.finger.ok = f.ok;
    assets.inom.img = i.img; assets.inom.ok = i.ok;

    const missing = [];
    if (!assets.mouth.ok) missing.push('mouth.png');
    if (!assets.finger.ok) missing.push('finger.png');
    if (!assets.inom.ok) missing.push('inom.png');
    if (missing.length) {
      hintChip.textContent = `ì´ë¯¸ì§€ ë¯¸ë¡œë“œ: ${missing.join(', ')} (ë„í˜•ìœ¼ë¡œ ëŒ€ì²´)`;
      setTimeout(() => { if (!state.gameOver) hintChip.textContent = 'ì†ê°€ë½ì„ í„°ì¹˜!'; }, 2200);
    }

    runSelfTests();

    resetGame();
    requestAnimationFrame((t) => { state.lastTs = t; loop(t); });
  }

  boot();
})();
</script>
</body>
</html>

